window.onPostDataLoaded({
    "title": "Stale-While-Revalidate: Next.js API Cache Invalidation Woes",
    "slug": "nextjs-api-stale-while-revalidate-invalidation",
    "language": "Next.js (React)",
    "code": "CacheInvalidationIssue",
    "tags": [
        "nextjs",
        "api-routes",
        "caching",
        "stale-while-revalidate",
        "invalidation"
    ],
    "analysis": "<p>The Stale-While-Revalidate (SWR) caching strategy is a powerful pattern for building performant web applications, especially within frameworks like Next.js. It allows the UI to display stale data immediately while fetching fresh data in the background. However, when implementing SWR within Next.js API Routes, particularly for data that can be modified, developers often encounter tricky cache invalidation issues. The core problem arises because API Routes, unlike client-side components, execute on the server. When an API route that serves cached data is also responsible for updating that data, a race condition can occur. The client might request data, receive stale data from the cache, and then trigger an update. Simultaneously, another client might be fetching the same data. If the update mechanism isn't perfectly synchronized with the cache invalidation, the new data might not be immediately reflected, or worse, the stale data could be served again.</p><p>Next.js's built-in data fetching methods (like <code>getServerSideProps</code> or <code>getStaticProps</code>) and client-side SWR hooks have different lifecycle and caching mechanisms. When an API route is used to both serve and mutate data, developers must explicitly manage the cache invalidation process. Simply updating the underlying data source (e.g., a database) doesn't automatically invalidate the cached response served by the API route if it's being cached at the network level or within the application's memory. This leads to the 'stale-while-revalidate' not behaving as expected, as the 'revalidate' part might be delayed or missed entirely.</p>",
    "root_cause": "Race conditions between data mutation and cache invalidation in server-side API routes.",
    "bad_code": "```javascript\n// pages/api/items/[id].js\nimport { cache } from '../../lib/cache'; // Assume a simple in-memory cache\n\nexport default async (req, res) => {\n  const { id } = req.query;\n\n  if (req.method === 'PUT') {\n    // Update item data (e.g., in database)\n    const updatedItem = await updateItemInDatabase(id, req.body);\n    // PROBLEM: Cache is not explicitly invalidated here\n    res.status(200).json(updatedItem);\n  } else {\n    // Fetch and serve item data\n    let item = cache.get(id);\n    if (!item) {\n      item = await fetchItemFromDatabase(id);\n      cache.set(id, item);\n    }\n    res.status(200).json(item);\n  }\n};\n```",
    "solution_desc": "To effectively implement Stale-While-Revalidate in Next.js API routes that also handle mutations, explicit cache invalidation is crucial. This involves clearing the relevant cached entry after a successful data update. For an in-memory cache, this means removing the entry. In a more robust caching system (like Redis or a CDN), this would involve sending an invalidation command. When using client-side SWR, the library itself provides mechanisms like <code>mutate</code> which can trigger revalidation, but when the API route itself is the source of truth and potentially caching, manual invalidation is often necessary.",
    "good_code": "```javascript\n// pages/api/items/[id].js\nimport { cache } from '../../lib/cache'; // Assume a simple in-memory cache\n\nexport default async (req, res) => {\n  const { id } = req.query;\n\n  if (req.method === 'PUT') {\n    const updatedItem = await updateItemInDatabase(id, req.body);\n    // SOLUTION: Explicitly invalidate the cache entry for this item\n    cache.del(id);\n    res.status(200).json(updatedItem);\n  } else {\n    let item = cache.get(id);\n    if (!item) {\n      item = await fetchItemFromDatabase(id);\n      cache.set(id, item);\n    }\n    res.status(200).json(item);\n  }\n};\n```",
    "verification": "1. Make a GET request to `/api/items/:id` to fetch an item. It should be served from the cache on subsequent requests if not updated. 2. Make a PUT request to `/api/items/:id` to update the item. 3. Immediately make another GET request to `/api/items/:id`. It should now serve the updated data, indicating successful invalidation and re-fetching. If the cache was not invalidated, the stale data would be served again.",
    "date": "2026-02-09",
    "id": 1770622460
});