window.onPostDataLoaded({
    "title": "The Ownership Wall: Understanding and Preventing Deadlocks with Rust's `Arc<Mutex<T>>`",
    "slug": "arc-mutex-deadlock-prevention-rust",
    "language": "en",
    "code": "Arc<Mutex<T>>",
    "tags": [
        "rust",
        "concurrency",
        "deadlock",
        "mutex",
        "arc",
        "thread-safety"
    ],
    "analysis": "Rust's strict ownership model makes concurrent programming safer, primarily by eliminating data races at compile time. However, it cannot prevent logical errors inherent to multiprocessing, such as deadlocks. The combination of `Arc` (Atomically Reference Counted) for shared ownership and `Mutex` for exclusive, synchronized access to mutable data (`Arc<Mutex<T>>`) is the standard pattern for shared state. A deadlock occurs when two or more threads are perpetually waiting for each other to release resources (locks).\n\nIn the context of `Arc<Mutex<T>>`, a deadlock most often happens when a thread attempts to acquire two or more independent locks, but the order of acquisition varies between threads. When Thread A holds Lock X and waits for Lock Y, and Thread B holds Lock Y and waits for Lock X, the system halts. While Rust guarantees the `MutexGuard` will release the lock upon drop, it cannot enforce the order in which locks are acquired across the entire program.",
    "root_cause": "Inconsistent lock acquisition hierarchy. The system contains two independent resources (A and B), each protected by a `Mutex`. Thread 1 acquires (A) then (B). Concurrently, Thread 2 acquires (B) then (A). This circular wait dependency creates a classic deadlock.",
    "bad_code": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let resource_a = Arc::new(Mutex::new(0));\n    let resource_b = Arc::new(Mutex::new(0));\n\n    // T1: Locks A then B\n    let a1 = Arc::clone(&resource_a);\n    let b1 = Arc::clone(&resource_b);\n    let t1 = thread::spawn(move || {\n        println!(\"T1: Attempting to lock A...\");\n        let mut guard_a = a1.lock().unwrap();\n        *guard_a += 1;\n        thread::sleep(Duration::from_millis(50)); // Hold A for a moment\n        println!(\"T1: Locked A, now attempting to lock B...\");\n        let mut guard_b = b1.lock().unwrap(); // Waits indefinitely if T2 holds B\n        *guard_b += 1;\n        println!(\"T1: Finished successfully.\");\n    });\n\n    // T2: Locks B then A (Inconsistent Order)\n    let a2 = Arc::clone(&resource_a);\n    let b2 = Arc::clone(&resource_b);\n    let t2 = thread::spawn(move || {\n        println!(\"T2: Attempting to lock B...\");\n        let mut guard_b = b2.lock().unwrap();\n        *guard_b += 10;\n        thread::sleep(Duration::from_millis(50)); // Hold B for a moment\n        println!(\"T2: Locked B, now attempting to lock A...\");\n        let mut guard_a = a2.lock().unwrap(); // Waits indefinitely if T1 holds A\n        *guard_a += 10;\n        println!(\"T2: Finished successfully.\");\n    });\n\n    t1.join().unwrap(); // Program hangs here\n    t2.join().unwrap();\n    println!(\"All threads finished.\");\n}",
    "solution_desc": "The primary strategy for preventing deadlocks involving multiple mutexes is establishing a strict lock hierarchy or ordering convention. All threads must acquire the locks in the exact same sequence. If we define the hierarchy as 'Resource A must always be locked before Resource B,' the circular dependency is broken, guaranteeing that if a thread holds A, it will not block waiting for B if another thread simultaneously holds B (because the other thread must have first acquired A, which it cannot do if the first thread holds it).\n\nAlternatively, restructuring the code to use a single lock for related data, minimizing lock scope, or utilizing Rust's `std::sync::mpsc` channels for communication (passing ownership rather than sharing mutable state) are strong architectural solutions.",
    "good_code": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let resource_a = Arc::new(Mutex::new(0));\n    let resource_b = Arc::new(Mutex::new(0));\n\n    // T1: Locks A then B (Hierarchy: A -> B)\n    let a1 = Arc::clone(&resource_a);\n    let b1 = Arc::clone(&resource_b);\n    let t1 = thread::spawn(move || {\n        println!(\"T1: Attempting to lock A...\");\n        let mut guard_a = a1.lock().unwrap();\n        *guard_a += 1;\n        thread::sleep(Duration::from_millis(50));\n        println!(\"T1: Locked A, now attempting to lock B...\");\n        let mut guard_b = b1.lock().unwrap();\n        *guard_b += 1;\n        println!(\"T1: Finished successfully.\");\n    });\n\n    // T2: Locks A then B (Consistent Order)\n    let a2 = Arc::clone(&resource_a);\n    let b2 = Arc::clone(&resource_b);\n    let t2 = thread::spawn(move || {\n        println!(\"T2: Attempting to lock A...\"); // FIX: Lock A first\n        let mut guard_a = a2.lock().unwrap();\n        *guard_a += 10;\n        thread::sleep(Duration::from_millis(50));\n        println!(\"T2: Locked A, now attempting to lock B...\");\n        let mut guard_b = b2.lock().unwrap();\n        *guard_b += 10;\n        println!(\"T2: Finished successfully.\");\n    });\n\n    t1.join().unwrap();\n    t2.join().unwrap();\n    \n    let final_a = resource_a.lock().unwrap();\n    let final_b = resource_b.lock().unwrap();\n    println!(\"All threads finished. Final A: {}, Final B: {}\", final_a, final_b);\n}",
    "verification": "The 'bad code' example will hang indefinitely as the threads wait circularly. The 'good code' establishes a consistent lock acquisition hierarchy (A then B). Although threads may pause while waiting for A to be released, they will eventually acquire both locks and complete execution. The successful completion and printing of the final resource values (A=11, B=11) verifies the deadlock has been prevented.",
    "date": "2026-02-09",
    "id": 1770609986
});