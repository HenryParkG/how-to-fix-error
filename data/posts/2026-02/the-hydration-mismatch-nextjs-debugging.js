window.onPostDataLoaded({
    "title": "The Hydration Mismatch: Next.js Debugging Guide",
    "slug": "the-hydration-mismatch-nextjs-debugging",
    "language": "Next.js / React",
    "code": "HydrationError",
    "tags": [
        "Next.js",
        "React",
        "SSR",
        "Hydration",
        "Debugging"
    ],
    "analysis": "<p>Hydration is the process where React takes the static HTML rendered by the server (Server-Side Rendering, or SSR) and attaches the client-side JavaScript, making the application interactive. A Hydration Mismatch occurs when the Virtual DOM (VDOM) tree generated by React on the client differs structurally or content-wise from the pre-rendered HTML received from the server.</p><p>In Next.js, all components rendered during a page request are first run on the Node.js server environment. This environment lacks browser-specific APIs (like <code>window</code>, <code>document</code>, or <code>localStorage</code>). If a component synchronously attempts to access these APIs, the server render produces one output (often missing the dynamic content), while the client render produces a different one (including the dynamic content), causing React to fail when attaching listeners.</p><p>Common triggers include:</p><ul><li>Accessing browser storage (<code>localStorage</code>, <code>sessionStorage</code>) outside of <code>useEffect</code>.</li><li>Rendering logic that relies on non-deterministic values (e.g., <code>Date.now()</code>) without synchronizing them between client and server.</li><li>Using external libraries that perform DOM manipulation immediately upon import.</li><li>Conditional rendering based on device or user agent without using Next.jsâ€™s supported strategies for fetching such data.</li></ul>",
    "root_cause": "Non-deterministic rendering logic or synchronous execution of client-side-only side effects during the initial render pass.",
    "bad_code": "function UserGreeting() {\n  // FAILS: localStorage is undefined on the server\n  const theme = localStorage.getItem('app_theme');\n  \n  return (\n    <div className={theme === 'dark' ? 'dark' : 'light'}>\n      Welcome to our site!\n    </div>\n  );\n}",
    "solution_desc": "The primary solution is to strictly enforce the separation of server rendering logic and client-side side effects. Any code that relies on browser APIs or client-specific data must be executed within a lifecycle method that guarantees client-side execution, most commonly <code>useEffect</code>. We initialize the relevant state variable to a server-safe default (e.g., <code>null</code> or <code>'light'</code>), and then update this state once the component mounts (client-side), ensuring the server and client render the identical initial DOM structure.",
    "good_code": "import React, { useState, useEffect } from 'react';\n\nfunction UserGreeting() {\n  // Initialize to a server-safe default\n  const [theme, setTheme] = useState('light');\n\n  useEffect(() => {\n    // Client-side only execution\n    const storedTheme = localStorage.getItem('app_theme');\n    if (storedTheme) {\n      setTheme(storedTheme);\n    }\n  }, []);\n\n  return (\n    <div className={theme === 'dark' ? 'dark' : 'light'}>\n      Welcome to our site!\n    </div>\n  );\n}",
    "verification": "Run a full production build using <code>next build</code> and <code>next start</code>. Open the application in the browser and monitor the console for hydration warnings. Use React Developer Tools to inspect the component structure immediately after load, ensuring no structural differences are present before client-side effects run.",
    "date": "2026-02-09",
    "id": 1770609676
});