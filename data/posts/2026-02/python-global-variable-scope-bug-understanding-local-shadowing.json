{
    "title": "The Python 'global' Trap: Understanding Why Function Assignment Creates Silent Bugs",
    "slug": "python-global-variable-scope-bug-understanding-local-shadowing",
    "language": "Python",
    "code": "UnboundLocalError / Scope Shadowing",
    "tags": [
        "Python",
        "Scope",
        "Global Variables",
        "Debugging",
        "Best Practices",
        "LEGB"
    ],
    "analysis": "<code>UnboundLocalError</code> is often the runtime manifestation of a fundamental misunderstanding of Python's scope rules, specifically concerning global variables. Python adheres to the LEGB rule (Local, Enclosing, Global, Built-in) for name resolution. When the interpreter encounters a variable name, it first checks the current local scope. <p>The critical mechanism here is that Python determines the scope of a variable at compile time based on whether an assignment operator (<code>=</code>) appears anywhere in the function body. If Python detects an assignment for a variable name within a function, it automatically flags that variable as <b>local</b> to that function, regardless of whether a global variable of the same name exists.</p> If you attempt to <i>read</i> the value of that variable (e.g., <code>count = count + 1</code>) before the assignment has been fully executed, the interpreter throws an <code>UnboundLocalError</code> because it is looking for the local variable <code>count</code>, which hasn't been initialized yet.",
    "root_cause": "The specific root cause is Python's implicit declaration rule for local variables. If an assignment happens within a function, the variable is local by default. This design choice prevents accidental mutation of global state, enforcing code modularity. When a developer attempts to modify a global variable, they often write code like <code>var = var + 1</code>. Because the <code>var = ...</code> part signals an assignment, Python registers <code>var</code> as local. Then, the expression <code>var + 1</code> attempts to retrieve the (uninitialized) local <code>var</code>, leading to the runtime error. If the code only involves reading the global variable (no assignment), it works fine, making the assignment operation the point of failure.",
    "bad_code": "total_hits = 100\n\ndef increment_hits():\n    # The assignment operator '=' here causes Python to treat total_hits as local.\n    # Trying to read the local total_hits (RHS) before it is assigned (LHS) causes the error.\n    total_hits = total_hits + 1\n    print(f\"Local hits: {total_hits}\")\n\ntry:\n    increment_hits()\nexcept UnboundLocalError as e:\n    print(f\"Caught Error: {e}\")\n\nprint(f\"Global total_hits remains: {total_hits}\")",
    "solution_desc": "The correct solution involves explicitly declaring the intent to modify the global variable using the <code>global</code> keyword. By placing <code>global total_hits</code> at the beginning of the function, we instruct the Python interpreter to bind the name <code>total_hits</code> within the function scope to the variable defined in the global scope, rather than creating a new local variable. <p><b>Best Practices:</b> While <code>global</code> provides the necessary fix, senior developers generally advise against using mutable global state heavily. For configuration (constants), globals are acceptable. For managing dynamic state, the superior approaches are:</p> <ol> <li><b>Pass State:</b> Design the function to accept the variable as a parameter and return the new value (functional purity).</li> <li><b>Encapsulation:</b> Use a class (e.g., a Singleton or a utility class) to encapsulate the state. The variable becomes an instance or class attribute, accessed via <code>self.total_hits</code> or <code>ClassName.total_hits</code>, which clearly signals mutation of shared state.</li> </ol>",
    "good_code": "total_hits = 100\n\ndef increment_hits_corrected():\n    global total_hits  # Explicitly bind the name to the global scope\n    total_hits = total_hits + 1\n    print(f\"Inside function, updated hits: {total_hits}\")\n\nincrement_hits_corrected()\nincrement_hits_corrected()\n\nprint(f\"Global total_hits final value: {total_hits}\")",
    "verification": "The fix is verified by printing the global variable's value outside the function before and after execution. If the <code>global</code> keyword is correctly used, the final printed value of <code>total_hits</code> will reflect the changes made inside the function (in this case, 102). <p><b>Edge Case Warning: Mutability vs. Rebinding.</b> If the global variable is a mutable object (like a list or dictionary), you do NOT need the <code>global</code> keyword to modify its contents (e.g., <code>my_list.append(x)</code>). This is because you are modifying the object referenced by the global name, not reassigning the name itself. The <code>global</code> keyword is only required when you wish to <i>rebind</i> the variable name to a new object (e.g., <code>my_list = [1, 2, 3]</code>).</p> To avoid this issue in the future, configure static analysis tools like Pylint or Pyflakes to warn against implicit variable shadowing or excessive use of the <code>global</code> keyword.",
    "date": "2026-02-09",
    "id": 1770602744
}