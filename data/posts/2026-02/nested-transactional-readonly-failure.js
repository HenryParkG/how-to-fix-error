window.onPostDataLoaded({
    "title": "Nested @Transactional ReadOnly Fails",
    "slug": "nested-transactional-readonly-failure",
    "language": "Java/Spring",
    "code": "Propagation.NESTED",
    "tags": [
        "spring",
        "transactional",
        "readonly",
        "propagation"
    ],
    "analysis": "<p>In Spring, the <code>@Transactional</code> annotation is a powerful tool for managing database transactions. Developers often leverage it to ensure atomicity, consistency, isolation, and durability (ACID) for their data operations. A common scenario involves nesting transactional methods, where one transactional method calls another.</p><p>When dealing with read-only operations, developers might annotate an inner method with <code>@Transactional(readOnly = true)</code>. The intention is to signal to the database and the transaction manager that this specific operation will not modify data, potentially allowing for performance optimizations like bypassing dirty checking or using specific database read-only modes. However, when this <code>readOnly = true</code> method is invoked within a transaction that is not itself read-only, and importantly, when using <code>Propagation.NESTED</code> or <code>Propagation.REQUIRED</code> (which defaults to nested behavior for existing transactions), a subtle but critical issue arises.</p><p>The Spring transaction manager, when encountering a <code>readOnly = true</code> transaction at any level, attempts to enforce this read-only constraint across the entire active transaction scope. If an outer transaction is *not* read-only (meaning it's capable of writes), and an inner transaction is explicitly marked as read-only, Spring may struggle to reconcile these conflicting directives, especially when using nested transaction semantics. The core of the problem lies in how the transaction manager manages transaction boundaries and states. A read-only transaction cannot naturally accommodate writes from an outer, non-read-only transaction if the read-only constraint is enforced at a lower level.</p><p>This often manifests as a <code>NestedServletException</code>, wrapping a lower-level exception related to transaction management, such as <code>org.springframework.transaction.TransactionSystemException</code> or specific JDBC exceptions indicating an attempt to write to a read-only transaction. The exception message might be cryptic, alluding to a problem with the transaction status or an attempt to perform an invalid operation on a read-only transaction context.</p>",
    "root_cause": "Spring's transaction manager enforcing read-only constraint from inner to outer transaction with nested propagation.",
    "bad_code": "```java\npublic class MyService {\n\n    @Transactional\n    public void outerTransactionalMethod() {\n        // ... perform some writes ...\n        innerReadOnlyMethod(); // Calls the read-only method\n        // ... perform more writes ...\n    }\n\n    @Transactional(readOnly = true)\n    public void innerReadOnlyMethod() {\n        // ... perform only reads ...\n        // Even if no writes happen here, calling this\n        // from a non-read-only outer transaction can cause issues\n        // if the outer transaction later attempts writes.\n    }\n}\n```",
    "solution_desc": "The most robust solution is to ensure that if an inner transactional method is marked as <code>readOnly = true</code>, it must be called from an outer transactional context that is also <code>readOnly = true</code> or does not impose a conflicting read-only state. Alternatively, if the outer method *must* perform writes, the inner method should not be marked as <code>readOnly = true</code>. A common pattern is to use <code>Propagation.REQUIRES_NEW</code> for the read-only method if it truly needs its own independent, read-only transaction. However, this often deviates from the desired behavior of a truly nested, read-only *operation* within a larger write transaction. The cleanest approach is to avoid nesting a <code>readOnly = true</code> method within a non-read-only method if the nested propagation is used.",
    "good_code": "```java\npublic class MyService {\n\n    // Option 1: If inner needs to be readOnly, outer must be too\n    @Transactional(readOnly = true)\n    public void outerReadOnlyMethodCallingReadOnly() {\n        // ... perform only reads ...\n        innerReadOnlyMethod();\n        // ... perform more reads ...\n    }\n\n    @Transactional(readOnly = true)\n    public void innerReadOnlyMethod() {\n        // ... perform only reads ...\n    }\n\n    // Option 2: If outer needs to write, inner should not be readOnly\n    // if called with nested propagation.\n    @Transactional\n    public void outerTransactionalMethodWithWrites() {\n        // ... perform some writes ...\n        innerWriteMethod(); // A method not marked readOnly=true\n        // ... perform more writes ...\n    }\n\n    @Transactional\n    public void innerWriteMethod() {\n        // ... perform reads and writes ...\n    }\n}\n```",
    "verification": "To verify the fix, ensure that the application runs without the specific <code>TransactionSystemException</code> or <code>NestedServletException</code> related to read-only transaction violations when the problematic nested calls are made. Unit tests can be written using Spring's transactional test support (e.g., <code>@Transactional</code> on test methods) to simulate the scenarios. Observe the logs for any transaction-related errors. For integration tests, deploy the application and trigger the endpoints that invoke the nested transactional methods, confirming successful execution and data integrity (or lack thereof, if it's a read-only path).",
    "date": "2026-02-09",
    "id": 1770622781
});