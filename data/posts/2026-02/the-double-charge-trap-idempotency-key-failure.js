window.onPostDataLoaded({
    "title": "The Double-Charge Trap: Idempotency Key Failure",
    "slug": "the-double-charge-trap-idempotency-key-failure",
    "language": "API Gateway / Microservices",
    "code": "DuplicateExecution",
    "tags": [
        "idempotency",
        "api-design",
        "microservices",
        "network-reliability",
        "payment-processing"
    ],
    "analysis": "<p>The Double-Charge Trap occurs when a client initiates a state-changing operation (like a financial transaction or resource creation) and the network connection fails or times out after the server successfully processes the request, but before the client receives the confirmation response.</p><p>Standard robust client libraries are configured to automatically retry failed or timed-out requests. Without an idempotency mechanism, the API gateway or downstream service treats the retried request as a brand new operation. This leads to critical errors, such as processing the same payment twice, creating duplicate user accounts, or triggering multiple unnecessary background jobs.</p><p>Idempotency is achieved by requiring the client to supply a unique, probabilistic identifier (the Idempotency Key), usually in a request header. The API gateway must then use this key to atomically check for prior execution. If the key exists and the transaction succeeded, the service immediately returns the original success response (201 Created or 200 OK) without executing the business logic again.</p>",
    "root_cause": "Failure of the API Gateway or downstream service to check for a unique, client-provided identifier before executing a state-changing operation, coupled with standard client retry logic responding to transient network failures.",
    "bad_code": "POST /api/v1/payments HTTP/1.1\nHost: api.service.com\nContent-Type: application/json\n\n{\n  \"amount\": 100.00,\n  \"user_id\": \"user_456\"\n}",
    "solution_desc": "The implementation requires introducing a mandatory request header (Idempotency-Key) containing a strong UUID or similar unique identifier generated by the client. The API gateway must enforce the presence and uniqueness of this key. Before processing the request, the service must use a highly concurrent key-value store (like Redis or a dedicated database table) to perform a lookup and transactionally reserve the key, ensuring the critical path only runs once. Keys must be stored with a short Time-To-Live (TTL) appropriate for the specific domain (e.g., 24 hours for payment processing).",
    "good_code": "POST /api/v1/payments HTTP/1.1\nHost: api.service.com\nContent-Type: application/json\nIdempotency-Key: e6b4d0c9-1234-5678-abcd-9012ef345678\n\n{\n  \"amount\": 100.00,\n  \"user_id\": \"user_456\"\n}",
    "verification": "Use a test harness to simulate network flakiness. Send a state-changing request (e.g., payment creation) including a unique Idempotency-Key. Force a timeout or network partition immediately after the backend service completes the transaction but before it sends the HTTP 201 response. Configure the client to retry the request using the exact same Idempotency-Key. Verify that the system logs show the downstream service logic only executed once, and the second API call returns the cached success response from the first execution.",
    "date": "2026-02-09",
    "id": 1770610168
});